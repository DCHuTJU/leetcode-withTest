### 最长上升子序列

最长上升子序列一定是与次长自序列有关系的，因此可以考虑使用动态规划解题。

##### 状态定义

`dp[i]`表示以`nums[i]`结束的最长上升子序列长度

##### 规划过程

需要考虑两种情况：
* 若`nums[i]`比前面的所有元素都小，那么`dp[i]`等于1（即本身）
* 若`nums[i]`前面存在一个比他小的元素，那么`dp[i] = dp[j] + 1`（`j`为小的元素的坐标）

> 但存在这样的情况，`nums[i]`前面存在多个比他小的元素，`j,k,l`，此时应该是对三个进行对比，选择最大的：
```go
dp[i] = max(dp[j]+1, dp[k]+1, dp[l]+1)
```
具体代码为：
```go
for j:=0; j<i; j++ {
	if nums[j] < nums[i] {
		dp[i] = max(dp[j]+1, dp[i])
	}
}
```
